# Copyright (C) 2016-2025 Gregory Stula
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# If ssh connection, then start (or continue) a tmux session before doing anything
if command -v tmux &>/dev/null && [[ -z "$TMUX" ]] && [ "$SSH_CONNECTION" != "" ]; then
	tmux attach-session -t ssh_tmux || tmux new-session -s ssh_tmux
	exit
fi

#Profiler for performance issues
zmodload zsh/zprof

# the autozcompile function is defined in ~/.zshenv
autozcompile "${HOME}/.zshrc"

# Essential exports for config functionality
source /etc/profile
export zsh_folder="$HOME/.zsh"

# See: https://github.com/gregstula/unix-config
export unixconfig="$HOME/unix-config/"

# Enable built-in zsh auto completion
zstyle :compinstall filename "$HOME/.zshrc"
autoload -Uz compinit && compinit

# Use cache for completion performance boost
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache

# Case insensitive auto completion
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# Menu selection for completion
zstyle ':completion:*' menu select

# My minimalist prompt/theme
# ~ ->
PROMPT='%2~ -> '
#                                  user@hostname
RPROMPT='%F{8}%n@%m%f'

# Make it clear we've done sudo -s -E
if [[ $EUID = 0 ]]; then
	PROMPT="%F{red}  %n  :: ${PROMPT}%f"
fi

# zsh command history file
# Up or down arrow to access previous commands
HISTFILE=~/.zsh_history
HISTSIZE=1000000
SAVEHIST=1000000

# Built-in options
# Command History
setopt append_history         # Every zsh open appends one command history
setopt hist_expire_dups_first # When trimming go for duplicates first
setopt hist_find_no_dups      # No duplicates when searching.
setopt hist_ignore_dups       # Do not add repeated commands to history.
setopt hist_ignore_space      # Do not save commands that start with a space to history.
setopt hist_reduce_blanks     # Trim blanks from history
setopt hist_verify            # sudo !! expands to run sudo on last command, verify befor exec
setopt inc_append_history     # Update the histfile immedietly instead of shell exit
setopt share_history          # Share history with all sessions

# cd tweaks
setopt auto_cd           # Typing a directory name invokes cd on it
setopt auto_pushd        # Everytime you cd it's now in a stack history used like (cd -2)
setopt pushd_ignore_dups # Don't push multiple copies directory onto the directory stack.
setopt pushd_minus       # Swap the meaning of cd +1 and cd -1 to the opposite

# GLOBS
#     * - Matches any string.
#     ? - Matches any character.
#     ls ./**/*file* recursive globbing
#     ls (fi|an)* match any filename begginng with fi or an
#     sudo !! command history globbing put sudo before last command
#     ! - The history character.
#     # - The command character.
setopt extended_glob #  #, ~, and ^
setopt glob_dots     # glob on dotfiles
setopt glob_complete # glob matches as completions

# Pearl matching operator
# matching with the =~ operator will use Perl-Compatible Regular Expressions from the PCRE library
setopt rematchpcre

# Completion Behavior
setopt always_to_end    # Move cursor to end of word on completion
setopt auto_list        # List choices on ambiguous completion
setopt auto_menu        # Use menu completion after second tab
setopt auto_param_slash # Add trailing slash for directory completions
setopt complete_in_word # Complete from both ends of word
setopt list_packed      # Make completion list smaller
setopt menu_complete    # Cycle through completions with repeated tabs

# Random
setopt interactive_comments # Allows comments in the command line
unsetopt beep               # Shhhh

# Don't do any of this if root
if [[ $(id -u) -ne 0 ]]; then
	# Run fastfetch only once per session if available
	if [[ ! -f /tmp/fastfetch_run ]]; then
		if command -v fastfetch &>/dev/null; then
			fastfetch
			touch /tmp/fastfetch_run
		fi
	fi

	# shh-agent key utility when so you do not have to enter password
	# on each git push if using passphrase for keys
	if command -v keychain &>/dev/null && [[ $(id -u) -ne 0 ]]; then
		if [[ $(keychain -l) == "The agent has no identities." ]]; then
			command -v fastfetch &>/dev/null && fastfetch
			eval "$(keychain --lockwait 0 --eval id_ed25519)"
		else
			eval "$(keychain --quiet --eval id_ed25519)"
		fi
	fi

	# set vim as editor for everything ever
	export VISUAL=vim
	export EDITOR="$VISUAL"
	export SYSTEMD_EDITOR="$VISUAL"
	KERNEL=$(uname)

	if [[ $KERNEL == "Darwin" ]]; then
		# for homebrew and local executables
		export PATH=/usr/local/bin:$PATH:~/bin
	fi

	# Scripting Language Version Managers

	# Ruby version manager
	export PATH=$HOME/.rbenv/bin:$PATH
	test -s "$HOME/.rbenv/bin/rbenv" && eval "$(rbenv init -)"

	# Elixir version manager
	# shellcheck source=/dev/null
	test -s "$HOME/.kiex/scripts/kiex" && source "$HOME/.kiex/scripts/kiex"

	# NodeJS version manager
	# zsh speed up https://varun.ch/posts/slow-nvm/
	export NVM_LAZY_LOAD=true
	export NVM_COMPLETION=true

	# Rust cargo
	export PATH="$HOME/.cargo/bin:$PATH"

	# Go path
	export PATH=$PATH:$HOME/bin:$HOME/go/bin

	# Aliases
	# TODO: it's just supposed to put the line at the top, like clear but without clearing the terminal
	alias see="tput cup 0 0"

	if [[ $KERNEL == "Linux" ]]; then
		alias ls="ls --color=auto"
	fi

	if command -v nvim &>/dev/null; then
		alias vi=/usr/bin/vim
		alias vim=nvim
		export nvimrc=${HOME}/.config/nvim/init.lua
	fi
fi

# Root should just depend on what is installed at the OS level
if [[ $(id -u) -eq 0 ]]; then
    system_plugins=($(ls /usr/share/zsh/plugins/*/*plugin*.zsh))
    for plug in $system_plugins; do
        source $plug
    done
else
    # load plugins
    source ${zsh_folder}/load_plugins.zsh
fi
